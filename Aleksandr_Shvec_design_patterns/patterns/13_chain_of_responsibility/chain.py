""""""
from __future__ import annotations

"""
1. Объяснение паттерна
Представь, что ты пришёл в банк с заявкой на кредит. Сначала тебя встречает консультант — если 
сумма маленькая, он одобряет сразу. Если больше — передаёт менеджеру. Менеджер тоже может 
отказать и передать директору филиала. Каждый в цепочке принимает решение: обработать запрос 
самому или передать следующему. Цепочка обязанностей работает так же: запрос проходит через 
цепочку объектов-обработчиков, и каждый решает — обработать его или передать дальше.

2. Определение
Chain of Responsibility — поведенческий паттерн проектирования, который позволяет передавать 
запросы последовательно по цепочке обработчиков. Каждый обработчик решает, может ли он обработать
 запрос, и либо обрабатывает его, либо передаёт следующему в цепи.

3. Пошаговый план реализации

Создать абстрактный класс (или интерфейс) Handler с методом обработки запроса
Добавить в Handler ссылку на следующий обработчик в цепи
Реализовать метод для установки следующего обработчика (цепочка связывается)
В методе обработки: проверить, может ли текущий обработчик обработать запрос
Если может — обработать и (опционально) завершить цепочку
Если не может — передать запрос следующему обработчику
Создать конкретные классы-обработчики, наследующие Handler
В клиентском коде собрать цепочку и запустить обработку

4. Достоинства и недостатки
Достоинства:

Слабая связанность — отправитель запроса не знает, кто его обработает
Гибкость — легко добавлять/удалять обработчиков без изменения клиентского кода
Разделение ответственности — каждый обработчик отвечает за свою логику
Динамическая цепочка — можно менять порядок обработчиков в runtime

Недостатки:

Нет гарантии обработки — запрос может пройти всю цепочку и остаться необработанным
Сложность отладки — трудно отследить, где именно обработался запрос
Производительность — если цепочка длинная, запрос проходит через множество проверок


5. Где применяется на практике

Веб-фреймворки (Django, Flask) — middleware обрабатывают HTTP-запросы
Логирование — разные уровни (DEBUG, INFO, ERROR) обрабатываются разными логгерами
Системы валидации — каждый валидатор проверяет своё условие
Обработка событий в GUI — клик мыши передаётся от виджета к родителю
Системы поддержки — тикеты escalation (L1 → L2 → L3 поддержка)
Банковские системы — одобрение транзакций по лимитам
"""
from abc import ABC, abstractmethod


class SupportRequest:
	"""Запрос в техподдержку"""

	def __init__(self, level: int, description: str):
		self.level = level  # Уровень сложности: 1, 2, 3
		self.description = description


class SupportHandler(ABC):
	"""Абстрактный обработчик запросов"""

	def __init__(self):
		self._next_handler: SupportHandler | None = None

	def set_next(self, handler: SupportHandler) -> SupportHandler:
		"""Устанавливает следующий обработчик в цепочке"""
		self._next_handler = handler
		return handler  # Возвращаем handler для удобного связывания

	@abstractmethod
	def handle(self, request: SupportRequest) -> None:
		"""Обрабатывает запрос или передаёт дальше"""
		pass


class JuniorSupport(SupportHandler):
	"""Младший специалист — обрабатывает простые запросы"""

	def handle(self, request: SupportRequest) -> None:
		if request.level <= 1:
			print(f"[Junior] Обработал: {request.description}")
		elif self._next_handler:
			print(f"[Junior] Передаю дальше: {request.description}")
			self._next_handler.handle(request)
		else:
			print(f"[Junior] Не могу обработать и некому передать: {request.description}")


class MiddleSupport(SupportHandler):
	"""Средний специалист — обрабатывает запросы средней сложности"""

	def handle(self, request: SupportRequest) -> None:
		if request.level <= 2:
			print(f"[Middle] Обработал: {request.description}")
		elif self._next_handler:
			print(f"[Middle] Передаю дальше: {request.description}")
			self._next_handler.handle(request)
		else:
			print(f"[Middle] Не могу обработать и некому передать: {request.description}")


class SeniorSupport(SupportHandler):
	"""Старший специалист — обрабатывает сложные запросы"""

	def handle(self, request: SupportRequest) -> None:
		if request.level <= 3:
			print(f"[Senior] Обработал: {request.description}")
		else:
			print(f"[Senior] Запрос слишком сложный: {request.description}")


# Клиентский код
if __name__ == "__main__":
	# Создаём обработчиков
	junior = JuniorSupport()
	middle = MiddleSupport()
	senior = SeniorSupport()

	# Строим цепочку: Junior → Middle → Senior
	junior.set_next(middle).set_next(senior)

	# Создаём запросы разной сложности
	requests = [
		SupportRequest(1, "Как сбросить пароль?"),
		SupportRequest(2, "Ошибка подключения к БД"),
		SupportRequest(3, "Критическая уязвимость в системе"),
	]

	# Обрабатываем запросы
	print("=== Обработка запросов ===\n")
	for req in requests:
		junior.handle(req)
		print()

"""
[Junior] Обработал: Как сбросить пароль?

[Junior] Передаю дальше: Ошибка подключения к БД
[Middle] Обработал: Ошибка подключения к БД

[Junior] Передаю дальше: Критическая уязвимость в системе
[Middle] Передаю дальше: Критическая уязвимость в системе
[Senior] Обработал: Критическая уязвимость в системе

"""