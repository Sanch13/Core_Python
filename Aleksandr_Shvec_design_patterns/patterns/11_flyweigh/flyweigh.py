"""
Легковес — это структурный паттерн проектирования, который позволяет вместить бóльшее
количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее
состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

Неизменяемые данные объекта принято называть «внутренним состоянием». Все остальные данные —
это «внешнее состояние»

Шаги реализации
1. Разделите поля класса, который станет легковесом, на две части:
◦ внутреннее состояние: значения этих полей одинаковы для большого числа объектов;
◦ внешнее состояние (контекст): значения полей уникальны для каждого объекта.
2. Оставьте поля внутреннего состояния в классе, но убедитесь, что их значения неизменяемы. Эти
поля должны инициализироваться только через конструктор.
3.Превратите поля внешнего состояния в параметры методов, где эти поля использовались. Затем
удалите поля из класса.
4. Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты. Клиент
должен запрашивать из этой фабрики легковеса с определённым внутренним состоянием, а не
создавать его напрямую.
5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в
методы объекта легковеса.

Пошаговый план реализации
- Выдели общее состояние (intrinsic state), которое будет разделяться между объектами
- Выдели уникальное состояние (extrinsic state), которое будет передаваться в методы
- Создай класс Flyweight, хранящий только общее состояние
- Создай фабрику (FlyweightFactory), которая управляет созданием и переиспользованием легковесов
- Фабрика проверяет: если легковес с таким общим состоянием уже существует — возвращает его,
если нет — создаёт новый
- Клиентский код получает легковесы через фабрику и передаёт уникальное состояние при вызове методов

Преимущества и недостатки
✅ Экономит оперативную память.
❌ Расходует процессорное время напоиск/вычисление контекста.
❌ Усложняет код программы из-за введения множества дополнительных классов.

Достоинства и недостатки
✅ Достоинства:
Экономия памяти — особенно при большом количестве похожих объектов
Уменьшение количества объектов в системе
Централизованное управление общими данными

❌ Недостатки:
Усложнение кода — нужно разделять состояния и управлять ими
Затраты на поиск легковеса в фабрике (обычно O(1) через словарь, но всё же накладные расходы)
Потеря инкапсуляции — внешнее состояние хранится вне объекта
Не подходит, если объектов мало или они сильно различаются

Где применяется на практике
Текстовые редакторы: символы с одинаковым шрифтом и размером разделяют объект форматирования
Игры: деревья в лесу (текстура + модель общие, позиция уникальна), частицы эффектов
Графические библиотеки: примитивы с одинаковыми свойствами (цвет, толщина линии)
Веб: иконки, спрайты на странице
Базы данных: пул соединений к базе данных

Запомни ключевые моменты:
Intrinsic (общее) = неизменяемое, хранится в Flyweight
Extrinsic (уникальное) = изменяемое, передаётся в методы
Фабрика = контролирует создание и переиспользование
Когда применять:
Много похожих объектов
Объекты занимают много памяти
Большая часть состояния может быть общей

"""

from typing import Dict, Tuple


class TreeType:
	"""Легковес — хранит общее состояние (тип дерева)"""

	def __init__(self, name: str, color: str, texture: str):
		self.name = name  # intrinsic state
		self.color = color  # intrinsic state
		self.texture = texture  # intrinsic state

	def draw(self, x: int, y: int) -> None:
		"""Рисует дерево в конкретной позиции (extrinsic state)"""
		print(f"Рисую {self.name} ({self.color}, {self.texture}) в позиции ({x}, {y})")


class TreeFactory:
	"""Фабрика легковесов — управляет созданием и переиспользованием"""

	_tree_types: Dict[Tuple[str, str, str], TreeType] = {}

	@classmethod
	def get_tree_type(cls, name: str, color: str, texture: str) -> TreeType:
		"""Возвращает существующий или создаёт новый тип дерева"""
		key = (name, color, texture)

		if key not in cls._tree_types:
			print(f"[Фабрика] Создаю новый TreeType: {name}")
			cls._tree_types[key] = TreeType(name, color, texture)
		else:
			print(f"[Фабрика] Переиспользую существующий TreeType: {name}")

		return cls._tree_types[key]

	@classmethod
	def get_total_types(cls) -> int:
		"""Возвращает количество уникальных типов деревьев"""
		return len(cls._tree_types)


class Tree:
	"""Контекст — хранит уникальное состояние и ссылку на легковес"""

	def __init__(self, x: int, y: int, tree_type: TreeType):
		self.x = x  # extrinsic state
		self.y = y  # extrinsic state
		self.tree_type = tree_type  # ссылка на flyweight

	def draw(self) -> None:
		self.tree_type.draw(self.x, self.y)


class Forest:
	"""Клиентский код — использует легковесы"""

	def __init__(self):
		self.trees: list[Tree] = []

	def plant_tree(self, x: int, y: int, name: str, color: str, texture: str) -> None:
		"""Сажает дерево, переиспользуя типы через фабрику"""
		tree_type = TreeFactory.get_tree_type(name, color, texture)
		tree = Tree(x, y, tree_type)
		self.trees.append(tree)

	def draw(self) -> None:
		"""Рисует все деревья в лесу"""
		for tree in self.trees:
			tree.draw()

	def get_stats(self) -> None:
		"""Показывает статистику"""
		print(f"\n{'=' * 60}")
		print(f"Всего деревьев: {len(self.trees)}")
		print(f"Уникальных типов деревьев: {TreeFactory.get_total_types()}")
		print(f"Экономия памяти: вместо {len(self.trees)} объектов TreeType "
		      f"используется только {TreeFactory.get_total_types()}")
		print(f"{'=' * 60}\n")


# Демонстрация работы
if __name__ == "__main__":
	forest = Forest()

	# Сажаем много деревьев (в реальности их могут быть миллионы)
	print("=== Посадка деревьев ===\n")

	forest.plant_tree(1, 1, "Дуб", "зелёный", "грубая кора")
	forest.plant_tree(2, 3, "Берёза", "белый", "гладкая кора")
	forest.plant_tree(5, 7, "Дуб", "зелёный", "грубая кора")
	forest.plant_tree(8, 2, "Сосна", "тёмно-зелёный", "чешуйчатая кора")
	forest.plant_tree(10, 10, "Дуб", "зелёный", "грубая кора")
	forest.plant_tree(15, 4, "Берёза", "белый", "гладкая кора")

	print("\n=== Отрисовка леса ===\n")
	forest.draw()

	# Статистика
	forest.get_stats()


