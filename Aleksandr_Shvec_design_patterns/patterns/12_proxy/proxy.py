"""
Заместитель (Proxy) — это структурный паттерн проектирования, который предоставляет
объект-заменитель вместо реального объекта. Proxy контролирует доступ к оригинальному объекту,
позволяя выполнять дополнительные действия до или после обращения к нему.

Жизненная аналогия:
Представь, что ты хочешь встретиться с директором крупной компании. Ты не можешь просто прийти и
зайти к нему в кабинет — сначала ты общаешься с секретарём. Секретарь проверяет, есть ли у тебя
запись, нужна ли встреча, свободен ли директор. Только после этого тебя пропускают.
Секретарь — это Proxy (заместитель). Он контролирует доступ к реальному объекту (директору),
добавляет дополнительную логику (проверки, логирование), но при этом предоставляет тот же
интерфейс общения.

Пошаговый план реализации:
- Определить общий интерфейс — создать абстрактный класс или протокол, который будет реализован и
реальным объектом, и заместителем.
- Создать реальный объект (RealSubject) — класс, который выполняет основную бизнес-логику.
- Создать класс-заместитель (Proxy) — класс, который реализует тот же интерфейс и содержит ссылку
на реальный объект.
- Добавить дополнительную логику в Proxy — контроль доступа, ленивая инициализация, логирование,
кэширование и т.д.
- Делегировать вызовы — Proxy перенаправляет запросы реальному объекту после выполнения своей логики.

Достоинства и недостатки
Достоинства:
Контроль доступа — можно ограничить доступ к объекту (проверка прав, аутентификация).
Ленивая инициализация — откладываем создание тяжёлого объекта до момента, когда он действительно понадобится.
Логирование и кэширование — можно прозрачно добавить логирование запросов или кэширование результатов.
Удалённый доступ — Proxy может скрывать работу с удалёнными объектами (например, по сети).
Принцип открытости/закрытости — добавляем функциональность без изменения реального объекта.

Недостатки:
Усложнение кода — добавляется дополнительный уровень абстракции.
Задержка ответа — из-за дополнительной логики в Proxy может увеличиться время выполнения.

Где применяется на практике
Виртуальный Proxy — для отложенной загрузки тяжёлых объектов (изображений, больших файлов).
Защитный Proxy — для контроля доступа к объекту (проверка прав пользователя).
Удалённый Proxy — для работы с объектами на удалённых серверах (RPC, REST API).
Кэширующий Proxy — для сохранения результатов дорогих операций.
Логирующий Proxy — для отслеживания обращений к объекту.

Примеры из реальной жизни:
ORM (SQLAlchemy) — ленивая загрузка связанных объектов.
Nginx/Apache — reverse proxy для веб-серверов.
Django/Flask middleware — обработка запросов до передачи в view.
"""
from abc import ABC, abstractmethod


# 1. Общий интерфейс
class Database(ABC):
	@abstractmethod
	def query(self, sql: str) -> str:
		pass


# 2. Реальный объект
class RealDatabase(Database):
	def query(self, sql: str) -> str:
		return f"Executing query: {sql}"


# 3. Proxy с проверкой доступа
class DatabaseProxy(Database):
	def __init__(self, user_role: str):
		self.user_role = user_role
		self._real_database = None  # Ленивая инициализация

	def query(self, sql: str) -> str:
		# Дополнительная логика: проверка прав
		if not self._check_access(sql):
			return "Access denied: insufficient permissions"

		# Ленивая инициализация реального объекта
		if self._real_database is None:
			print("Initializing real database connection...")
			self._real_database = RealDatabase()

		# Логирование
		print(f"[LOG] User '{self.user_role}' executing query")

		# Делегирование вызова реальному объекту
		return self._real_database.query(sql)

	def _check_access(self, sql: str) -> bool:
		# Простая проверка: только admin может делать DELETE
		if "DELETE" in sql.upper() and self.user_role != "admin":
			return False
		return True


# Использование
if __name__ == "__main__":
	# Обычный пользователь
	user_db = DatabaseProxy(user_role="user")
	print(user_db.query("SELECT * FROM users"))
	print(user_db.query("DELETE FROM users"))

	print("\n" + "=" * 50 + "\n")

	# Администратор
	admin_db = DatabaseProxy(user_role="admin")
	print(admin_db.query("SELECT * FROM users"))
	print(admin_db.query("DELETE FROM users"))
