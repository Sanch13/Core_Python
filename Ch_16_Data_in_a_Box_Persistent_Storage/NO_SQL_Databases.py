import string

"""Хранилища данных NoSQL
Реляционные таблицы имеют форму прямоугольника, но поступающие данные могут иметь разную форму
и их размещение требует больших усилий. Это похоже на проблему квадратного колышка и круглой дырки.
Отдельные нереляционные базы данных позволяют более гибко определять данные, работают с очень
крупными наборами и поддерживают пользовательские операции с данными. Такие базы данных
называют NoSQL (раньше это означало «не SQL», теперь же расшифровка звучит как «не только SQL»).
Простейшей вариацией баз данных NoSQL являются хранилища ключей-значений."""

"""Семейство dbm
Форматы dbm существовали задолго до того, как появился NoSQL. Они представляют собой простые
хранилища, работающие по принципу «ключ — значение». Их часто встраивают в приложения вроде
браузеров, чтобы поддерживать различные настройки. База данных dbm похожа на обычный словарь в
следующих отношениях:
- вы присваиваете значение ключу, и оно автоматически сохраняется в базе данных на диске;
- вы можете получить ключ по его значению.
"""
"""Рассмотрим простой пример. Второй аргумент следующего метода open() может принимать значения
'r' для чтения, 'w' для записи и 'c' для того и другого, создавая файл, если его не существует"""
import dbm
db = dbm.open('definitions', 'c')
"""Для того чтобы создать пары «ключ — значение», просто присвойте значение ключу, как если бы
вы работали со словарем:"""
db['_mustard'] = '_yellow'
db['_ketchup'] = '_red'
db['_pesto'] = '_green'
# print(len(db))        # 3
# print(db['_pesto'])   # b'_green'
"""Теперь закроем файл и откроем его снова, чтобы убедиться, действительно ли
наши данные были сохранены"""
db.close()
db = dbm.open('definitions', 'r')
# print(db['_mustard'])   # b'_yellow'
db.close()
"""Ключи и значения сохраняются как байты. Вы не можете итерировать по объектам базы данных db,
но можете получить количество ключей с помощью функции len(). Обратите внимание на то, что
функции get() и setdefault() работают точно так же, как и для словарей"""

"""Memcached
memcached (http://memcached.org/) — это быстрый сервер кэширования, располагающийся в памяти
и работающий по принципу «ключ — значение». Часто его размещают перед базой данных или используют
для хранения данных сессии веб-сервера.
Вы можете загрузить версии для Linux, macOS (http://bit.ly/install-osx)
Windows (http://bit.ly/memcache-win).
Существует множество драйверов Python. Тот, что работает с Python 3, называется
python3-memcached (https://github.com/eguven/python3-memcached).
Ключи и значения, хранимые в базе, неустойчивы и могут исчезать. Это происходит из-за того,
что memcached является сервером кэша, а не базой данных. Он избегает ситуаций, когда у него
заканчивается память, стирая старые данные."""

"""Redis
Redis — это сервер структур данных. Он работает с ключами и их значениями, но значения имеют
гораздо больше возможностей, чем в других хранилищах. Как и в случае с memcached, все данные
сервера Redis должны поместиться в память (хотя у нас имеется возможность сохранить все данные
на диск). В отличие от memcached Redis может делать следующее:
- сохранять данные на диск для надежности в случае перезагрузки;
- хранить старые данные;
- предоставлять более сложные, по сравнению со строками, структуры данных.
Типы данных Redis близки к типам данных Python, и сервер Redis может быть полезным посредником
для обмена данными между приложениями.
Исходный код драйвера Python redis-py и тесты находятся на 
GitHub (https://github.com/andymccurdy/redis-py),
документация по нему находится по адресу http://bit.ly/redis-py-docs.
Сам по себе сервер Redis (http://redis.io/) хорошо задокументирован. Если вы установите и
запустите его на своем локальном компьютере, который имеет сетевое имя localhost, вы сможете
запустить программы, описанные в следующих подразделах.

Строки.
Ключ, имеющий одно значение, является строкой Redis. Простые типы данных Python автоматически
преобразуются. Подключимся к серверу Redis, расположенному на определенных хосте
(по умолчанию localhost) и порте (по умолчанию 6379):
"""

import redis
conn = redis.Redis()
"""Строки redis.Redis('localhost') или redis.Redis('localhost', 6379) дадут тот же результат."""
# conn.set('secret', 'ni!')
# conn.get('secret')    # b'ni!'
"""Метод setnx() устанавливает значение, но только если ключа не существует:"""
"""Метод getset() возвращает старое значение и одновременно устанавливает новое"""
# conn.getset('secret', 'icky-icky-icky-ptang-zoop-boing!')
# b'ni!'
# conn.get('secret')  # b'icky-icky-icky-ptang-zoop-boing!'
"""получим подстроку с помощью метода getrange() (как и в Python, 
смещение 0 означает начало списка, −1 — конец)"""
# conn.getrange('secret', -6, -1) # b'boing!'
"""Заменим подстроку с помощью метода setrange() (используя смещение, которое начинается с нуля)"""
# conn.setrange('secret', 0, 'ICKY')
# conn.get('secret')  # b'ICKY-icky-icky-ptang-zoop-boing!'
"""Далее установим значения сразу нескольких ключей с помощью метода mset():"""
# conn.mset({'pie': 'cherry', 'cordial': 'sherry'})
"""Получим более одного значения с помощью метода mget():"""
# conn.mget(['pie', 'cordial'])   # [b'cherry', b'sherry']
"""Удалим ключ с помощью метода delete():"""
# conn.delete('pie')
"""инкремент с помощью команд incr() и incrbyfloat() и декремент с помощью команды decr()"""
"""Команды decrbyfloat() не существует. Используйте отрицательный инкремент, 
чтобы уменьшить значение ключа"""

"""Списки. 
Списки Redis могут содержать только строки. Список создается, когда вы добавляете первые данные.
Добавим данные в начало списка с помощью метода lpush():"""
# conn.lpush('zoo', 'bear')   # 1 arg - название списка (явл. ключем), 2 - *arg - values
"""Добавим в начало списка более одного элемента:"""
# conn.lpush('zoo', 'alligator', 'duck')
"""Добавим один элемент до или после другого с помощью метода linsert()"""
# conn.linsert('zoo', 'before', 'bear', 'beaver')
"""Добавим элемент, указав смещение для него, с помощью метода lset() (список уже должен
 существовать):"""
# conn.lset('zoo', 2, 'marmoset')
"""Добавим элемент в конец с помощью метода rpush():"""
# conn.rpush('zoo', 'yak')
"""Получим элемент по заданному смещению с помощью метода lindex():"""
# conn.lindex('zoo', 3)   # b'bear'

"""Хеши.
Хеши Redis похожи на словари в Python, но содержат только строки, поэтому мы можем создать
только одномерный словарь. Рассмотрим примеры, в которых создается и изменяется хеш
с именем song."""
"""Установим в хеше song значения полей do и re одновременно с помощью метода hmset()"""
# conn.hmset('song', {'do': 'a deer', 're': 'about a deer'})
"""Установим значение одного поля хеша с помощью метода hset():"""
# conn.hset('song', 'mi', 'a note to follow re')
"""Получим значение одного поля с помощью метода hget()"""
# conn.hget('song', 'mi')     # b'a note to follow re'
"""Получим значение нескольких полей с помощью метода hmget():"""
# conn.hmget('song', 're', 'do')  # [b'about a deer', b'a deer']
"""Получим ключи всех полей хеша с помощью метода hkeys()"""
# conn.hkeys('song')     # [b'do', b're', b'mi']
"""Получим значения всех полей хеша с помощью метода hvals():"""
# conn.hvals('song')  # [b'a deer', b'about a deer', b'a note to follow re']
"""Получим количество полей хеша с помощью функции hlen()"""
# conn.hlen('song')   # 3
"""Получим ключи и значения всех полей хеша с помощью метода hgetall():"""
# conn.hgetall('song')  # {b'do': b'a deer', b're': b'about a deer', b'mi': b'a note to follow re'}
"""Создадим поле, если его ключ не существует, с помощью метода hsetnx():"""
# conn.hsetnx('song', 'fa', 'a note that rhymes with la')  # 1

"""Множества. 
Множества Redis похожи на множества Python, в чем вы сможете убедиться в следующих примерах."""
""""Добавим одно или несколько значений множества:"""
# conn.sadd('zoo', 'duck', 'goat', 'turkey')
"""Получим количество значений множества:"""
# conn.scard('zoo')   # 3
"""Получим все значения множества:"""
# conn.smembers('zoo')    # {b'duck', b'goat', b'turkey'}
"""Удалим значение из множества:"""
# conn.srem('zoo', 'turkey')

"""Упорядоченные множества.
Один из самых гибких типов данных Redis — это упорядоченное множество, или zset. Он представляет
собой набор уникальных значений, но с каждым значением связан счетчик с плавающей точкой. Вы можете
получить доступ к элементу по его значению или по счетчику. Упорядоченные множества применяются как:
- списки лидеров;
- списки вторичных индексов;
- временные ряды, где отметки времени используются как счетчик."""

"""Кэши и истечение срока действия. У всех ключей Redis есть время жизни, или дата истечения
срока действия. По умолчанию этот срок длится вечно. Мы можем использовать функцию expire(),
чтобы указать Redis, как долго хранить заданный ключ. Значением является количество секунд:"""
"""Команда expireat() указывает, что действие ключа истекает в заданное время epoch Unix. 
Истечение срока действия ключа полезно для поддержания свежести кэшей и ограничения количества 
сеансов входа в систему. Рассмотрим аналогию: в холодильнике, расположенном за стойками с
молоком в вашем продуктовом магазине, работники избавляются от галлонов молока, когда у тех
 истекает срок годности."""

"""Документоориентированные базы данных
Документоориентированные базы данных — это базы данных формата NoSQL, которые хранят данные с
разными полями. В сравнении с реляционной таблицей (прямоугольной формы, с одинаковыми 
столбцами для каждой строки) данные, хранящиеся в этих таблицах, являются ragged — могут
содержать разные поля (столбцы) в каждой строке, а также могут иметь вложенные поля. Можно
обрабатывать такие данные с помощью словарей и списков или же сохранять их в файлах JSON.
Для сохранения таких данных в реляционную таблицу нужно определить все возможные столбцы и 
использовать значения null для отсутствующих данных. ODM может расшифровываться как 
Object Data Manager или Object Document Mapper. ODM является документоориентированным 
аналогом ORM — реляционных баз данных.
Некоторые популярные (https://db-engines.com/en/ranking/document+store)
документоориентированные базы данных и инструменты (драйверы и ODM)
"""

"""PostgreSQL может выполнять некоторые задачи, которые выполняют и документоориентированные
базы данных. Его расширения позволяют избежать определенных минусов реляционных баз данных, но
сохраняют при этом такие особенности, как транзакции, валидация данных и внешние ключи: 
1) многомерные массивы (https://www.postgresql.org/docs/9.1/arrays.html) позволяют хранить
более одного значения в ячейке таблицы; 
2) jsonb (https://www.postgresql.org/docs/9.6/datatype-json.html) позволяет сохранить в ячейке
данные в формате JSON с полным индексированием и запросами."""

# TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS

"""16.1. Сохраните следующие несколько строк в файл books.csv. Обратите внимание на то, что, если
поля разделены запятыми, вам нужно заключить в кавычки поле, содержащее запятую:
author,book
J R R Tolkien,The Hobbit
Lynne Truss,"Eats, Shoots & Leaves"
"""
text = """author,book
J R R Tolkien,The Hobbit
Lynne Truss,"Eats, Shoots & Leaves"
"""
with open('books.csv', 'wt') as file:
    file.write(text)
###################################################################################################
"""16.2. Используйте модуль csv и его метод DictReader, чтобы считать содержимое файла books.csv 
в переменную books. Выведите на экран значения переменной books. Обработал ли метод DictReader 
кавычки и запятые в заголовке второй книги?
"""
import csv
# with open('books.csv', 'rt') as file:
#     books = csv.DictReader(file)
#     values = [value.get('book') for value in books]
# print(values)   # ['The Hobbit', 'Eats, Shoots & Leaves']
###################################################################################################
"""16.3. Создайте CSV-файл books1.csv и запишите его в следующие строки:
title,author,year
The Weirdstone of Brisingamen,Alan Garner,1960
Perdido Street Station,China Miéville,2000
Thud!,Terry Pratchett,2005
The Spellman Files,Lisa Lutz,2007
Small Gods,Terry Pratchett,1992"""
# books = """title,author,year
# The Weirdstone of Brisingamen,Alan Garner,1960
# Perdido Street Station,China Miéville,2000
# Thud!,Terry Pratchett,2005
# The Spellman Files,Lisa Lutz,2007
# Small Gods,Terry Pratchett,1992"""
# with open('books1.csv', 'wt', encoding='utf-8') as file:
#     file.write(books)
###################################################################################################
"""16.4. Используйте модуль sqlite3, чтобы создать базу данных SQLite books.db и таблицу books1,
содержащую следующие поля: title (текст), author (текст) и year (целое число)."""
"""16.5. Считайте данные из файла books1.csv и добавьте их в таблицу books."""
import sqlite3
conn = sqlite3.connect('books.db')
curs = conn.cursor()
curs.execute("""CREATE TABLE IF NOT EXISTS books
             (title VARCHAR(50) PRIMARY KEY,
             author VARCHAR(50),
             year INT)""")
ins = 'INSERT INTO books (title, author, year) VALUES(?, ?, ?)'
### ins_str = 'insert into books values(?, ?, ?)' # from books
with open('books1.csv', 'rt', encoding='utf-8') as file:
    data = csv.DictReader(file)
    data_in_bd = [(row.get('title'), row.get('author'), int(row.get('year'))) for row in data]
    for data in data_in_bd:
        curs.execute(ins, data)
print(curs.execute("SELECT * FROM books").fetchall())
# [
# ('The Weirdstone of Brisingamen', 'Alan Garner', 1960),
# ('Perdido Street Station', 'China Miéville', 2000),
# ('Thud!', 'Terry Pratchett', 2005),
# ('The Spellman Files', 'Lisa Lutz', 2007),
# ('Small Gods', 'Terry Pratchett', 1992)
# ]
###################################################################################################
"""16.6. Считайте и выведите на экран столбец title таблицы book в алфавитном порядке."""
# print(*curs.execute("SELECT title FROM books").fetchall())
# ('Perdido Street Station',)
# ('Small Gods',)
# ('The Spellman Files',)
# ('The Weirdstone of Brisingamen',)
# ('Thud!',)
###################################################################################################
"""16.7. Считайте и выведите на экран все столбцы таблицы book в порядке публикации."""
# print(curs.execute('SELECT year, title, author FROM books ORDER BY year').fetchall())
# [
# (1960, 'The Weirdstone of Brisingamen', 'Alan Garner'),
# (1992, 'Small Gods', 'Terry Pratchett'),
# (2000, 'Perdido Street Station', 'China Miéville'),
# (2005, 'Thud!', 'Terry Pratchett'),
# (2007, 'The Spellman Files', 'Lisa Lutz')
# ]
curs.close()
conn.close()
###################################################################################################
"""16.8. Используйте модуль sqlalchemy, чтобы подключиться к базе данных sqlite3 books.db, 
которую вы создали в упражнении 16.4. Как и в упражнении 16.6, считайте и выведите на экран
столбец title таблицы book в алфавитном порядке."""
import sqlalchemy as sa
conn_2 = sa.create_engine('sqlite:///books.db')
rows = conn_2.execute('SELECT title FROM books')
print([elem for elem in rows])
