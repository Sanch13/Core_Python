"""
Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять
объектам новую функциональность, оборачивая их в полезные «обёртки».

Аналогия из жизни:
Представь, что у тебя есть базовый кофе (эспрессо). Ты можешь "обернуть" его молоком → получится
капучино. Затем добавить сироп → получится сладкий капучино. Потом посыпать корицей → сладкий
капучино с корицей. Каждое "обёртывание" добавляет новую функциональность, но базовый кофе
остаётся тем же.

Decorator — паттерн, который расширяет функциональность объекта без изменения его структуры,
используя композицию вместо наследования. Декоратор имеет тот же интерфейс, что и оборачиваемый
объект, и может передавать ему запросы, добавляя своё поведение до или после передачи.

Пошаговый план реализации
- Создать базовый интерфейс (или абстрактный класс) — общий для всех компонентов
- Создать конкретный компонент — объект, к которому будем добавлять функциональность
- Создать базовый класс декоратора — он реализует тот же интерфейс и содержит ссылку на оборачиваемый объект
- Создать конкретные декораторы — каждый добавляет свою специфическую функциональность
- Использовать декораторы — оборачивать объект в нужные декораторы в любом порядке

Шаги реализации
1.Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений
или надстроек над ним.
2.Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так
и для его дополнений.
3.Создайте класс конкретного компонента и поместите в него основную бизнес-логику.
4.Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный
объект-компонент. Все методы базового декоратора должны делегировать действие вложенному объекту.
5.И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.
6.Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный
декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же
операцию обёрнутого объекта.
7.Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.

Преимущества и недостатки
✅ Большая гибкость, чем у наследования.
✅ Позволяет добавлять обязанности на лету.
✅ Можно добавлять несколько новых обязанностей сразу.
✅ Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.
❌ Трудно конфигурировать многократно обёрнутые объекты.
❌ Обилие крошечных классов.

Достоинства и недостатки
✅ Достоинства:
Гибкость — можно комбинировать поведение в разных комбинациях во время выполнения
Принцип открытости/закрытости — не нужно изменять существующий код
Разделение ответственности — каждый декоратор отвечает за одну функцию
Альтернатива наследованию — избегаем "взрыва подклассов"

❌ Недостатки:
Сложность отладки — много мелких объектов, вложенных друг в друга
Трудно удалить конкретную обёртку — из середины цепочки
Порядок декораторов имеет значение — может привести к ошибкам

Правильная структура (интерфейс → компонент → базовый декоратор → конкретные декораторы)
Где применяется на практике

Веб-фреймворки — добавление логирования, кеширования, проверки прав доступа к функциям
GUI библиотеки — добавление рамок, скроллбаров, теней к визуальным компонентам
Потоки ввода-вывода — BufferedReader, GZipInputStream обёртывают базовые потоки
Middleware — в веб-приложениях (обработка запросов, сжатие, аутентификация)
Логирование и мониторинг — добавление метрик к существующим функциям
"""

from abc import ABC, abstractmethod


# 1. Базовый интерфейс
class Coffee(ABC):
	@abstractmethod
	def cost(self) -> float:
		pass

	@abstractmethod
	def description(self) -> str:
		pass


# 2. Конкретный компонент (базовый кофе)
class Espresso(Coffee):
	def cost(self) -> float:
		return 50.0

	def description(self) -> str:
		return "Эспрессо"


# 3. Базовый декоратор
class CoffeeDecorator(Coffee):
	def __init__(self, coffee: Coffee):
		self._coffee = coffee

	def cost(self) -> float:
		return self._coffee.cost()

	def description(self) -> str:
		return self._coffee.description()


# 4. Конкретные декораторы
class Milk(CoffeeDecorator):
	def cost(self) -> float:
		return self._coffee.cost() + 20.0

	def description(self) -> str:
		return self._coffee.description() + " + Молоко"


class Syrup(CoffeeDecorator):
	def cost(self) -> float:
		return self._coffee.cost() + 15.0

	def description(self) -> str:
		return self._coffee.description() + " + Сироп"


class Cinnamon(CoffeeDecorator):
	def cost(self) -> float:
		return self._coffee.cost() + 5.0

	def description(self) -> str:
		return self._coffee.description() + " + Корица"


# 5. Использование
if __name__ == "__main__":
	# Простой эспрессо
	coffee = Espresso()
	print(f"{coffee.description()}: {coffee.cost()} руб.")

	# Эспрессо с молоком
	coffee = Milk(Espresso())
	print(f"{coffee.description()}: {coffee.cost()} руб.")

	# Эспрессо с молоком, сиропом и корицей
	coffee = Cinnamon(Syrup(Milk(Espresso())))
	print(f"{coffee.description()}: {coffee.cost()} руб.")

