import string

"""Когда вам нужно написать некий код, самым быстрым решением является кража…из тех источников, 
которые позволяют это делать. Стандартная библиотека Python (http://docs.python.org/3/library) 
широка, глубока и довольно понятна."""
"""Первое место, на которое вы должны обратить внимание, — это каталог пакетов Python 
(Python Package Index, PyPI) (https://pypi.org/)."""
"""Еще один популярный репозиторий — GitHub. Взгляните, какие пакеты Python популярны в данный 
момент (https://github.com/trending?l=python)."""
"""Сайт Popular Python recipes (http://bit.ly/popular-recipes) содержит более 4000 коротких 
программ Python на любую тему"""

"""virtualenv
Стандартный способ установки сторонних пакетов — это использование pip и virtualenv. 
Виртуальное окружение — это обычный каталог, содержащий интерпретатор Python, несколько других 
программ наподобие pip, а также некие пакеты. Вы можете активизировать его, запустив сценарий 
оболочки, который лежит в каталоге bin этого виртуального окружения. Это изменит значение 
переменной окружения $PATH, и теперь ваша оболочка будет знать, где искать программы. Активизируя
виртуальное окружение, вы помещаете его каталог bin перед остальными каталогами в переменной 
$PATH. В результате, когда вы введете такие команды, как pip или python, ваша оболочка сначала 
найдет те программы, которые располагаются в вашем виртуальном окружении, а не те, что находятся 
в системных каталогах"""

"""Добавление подсказок типов
Статические языки требуют от вас определять типы переменных, они могут отлавливать ошибки на 
этапе компиляции. Python так не делает, вы можете столкнуться с багом только при запуске кода. 
Переменные в Python — это имена, они лишь ссылаются на реальные объекты. Объекты имеют строго 
определенный тип, но имя может указывать на разные объекты в различные моменты времени.
В реальном коде (на Python и других языках) имя, как правило, ссылается на конкретный объект. 
Было бы полезно, по крайней мере в документации, если бы мы могли оставлять аннотации (к 
объектам, возвращаемым значениям функций и т. д.), указывавшие бы на ожидаемый тип объекта, 
на который они ссылаются. В таком случае разработчикам не пришлось бы просматривать большое 
количество кода, чтобы увидеть, как переменная должна вести себя. В Python версий 3.х для решения 
этой проблемы были добавлены подсказки типов (или аннотации типов). Ими пользоваться не 
обязательно, они не задают жесткий тип переменной. Подсказки типов предназначены для того, 
чтобы помочь разработчикам, привыкшим к статическим языкам, понять, где должны быть объявлены 
типы переменных. Подсказка для функции, которая преобразует строку в число, может выглядеть так:"""
def num_to_str(num: int) -> str:
    return str(num)
"""Это лишь подсказки, они не меняют способ работы Python. Они нужны для документирования, 
однако люди придумывают и другое применение. Например, веб-фреймворк FastAPI 
(https://fastapi.tiangolo.com/) использует подсказки для того, чтобы сгенерировать 
веб-документацию, а также лайв-формы для тестирования."""

"""Программы pylint, pyflakes, flake8 или PEP-8
Следующий шаг перед созданием настоящих программ для тестирования — использование контролера
кода Python. Самыми популярными являются pylint (http://www.pylint.org/) и 
pyflakes (http://bit.ly/pyflakes).Они проверяют на наличие реальных ошибок в коде 
(например, обращения к переменной до присвоения ей значения) и несоответствие стилю (как если бы
код носил одновременно одежду в полоску и клетку)."""
import pylint
# a = 1
# b = 2
# print(a)
# print(b)
# print(c)
"""Так выглядит выходная информация от pylint:"""
# Be_a_Pythonista.py:52:0: C0103: Constant name "a" doesn't conform to UPPER_CASE naming style (invalid-name)
# Be_a_Pythonista.py:53:0: C0103: Constant name "b" doesn't conform to UPPER_CASE naming style (invalid-name)
# Be_a_Pythonista.py:56:6: E0602: Undefined variable 'c' (undefined-variable)
"""Если пролистать дальше, к разделу Global evaluation, то можно увидеть наш счет
(10.0 — это высший балл):"""
# Your code has been rated at 0.00/10
"""исправим ошибку"""
a = 1
b = 2
c = 3
# print(a)
# print(b)
# print(c)

"""Тестирование кода
Возможно, вы уже знаете, однако на всякий случай напомню: даже тривиальные изменения в коде могут 
сломать вашу программу. В Python недостает проверки типов, присущей статическим языкам, 
что упрощает некоторые аспекты программирования, но повышает вероятность получить нежелательные 
результаты. Тестирование — это важно. Самый простой способ протестировать программы, написанные 
на Python, — добавить операторы print(). Read-Evaluate-Print Loop (REPL) интерактивного 
интерпретатора позволяет быстро изменять код и тестировать изменения. Однако в производственном 
коде операторы print() использовать не стоит, поэтому вам нужно помнить о том, что их все 
следует удалять.
"""

"""Пакет unittest
Хорошим тоном являются написание и запуск тестовых программ до отправки кода в систему контроля
исходного кода. Написание тестов поначалу может быть утомительным, но они действительно помогают 
находить проблемы быстрее, особенно регрессионные тесты (суть которых заключается в том, чтобы 
сломать то, что раньше работало). Болезненный опыт учит всех разработчиков: даже самое маленькое 
изменение, которое, по их заверениям, не затрагивает другие области приложения, на самом деле
влияет на них. Если вы взглянете на качественные пакеты Python, то заметите, что они поставляются
с набором тестов.Стандартная библиотека содержит не один, а целых два пакета для 
тестирования приложений. Начнем с unittest (https://oreil.ly/ImFmE). Модуль cap.by записывает 
слова с прописной буквы. Наша первая версия будет использовать стандартную строковую 
функцию capitalize().
Основная идея тестирования заключается в том, чтобы понять, какой результат вы хотите получить 
при определенных входных данных (в нашем примере вы хотите получить введенный текст записанным с 
прописной буквы), отправить результат функции тестирования, а затем проверить, получен ли 
ожидаемый результат. Ожидаемый результат называется утверждением (assertion), поэтому в рамках 
пакета unittest вы проверяете результат с помощью методов, чьи имена начинаются со слова assert, 
скажем метода assertEqual.
Перед каждым методом тестирования вызывается метод setUp(), а после каждого из методов 
тестирования — метод tearDown(). Их задача — выделение и освобождение внешних ресурсов, 
необходимых для тестов, таких как соединение с базой данных или создание неких тестовых данных. 
В нашем случае тесты автономны, и нам даже не нужно определять методы setUp() и tearDown(), 
однако создать их пустые версии не повредит. Сердце наших тестов — две функции с именами test_
one_word() и test_multiple_words(). Каждая из них запускает определенную нами функцию just_do_it(
) с разными входными параметрами и проверяет, получен ли ожидаемый результат. 
Эта команда вызовет два наших методатестирования:
    # AssertionError: 'A veritable flock of ducks' != 'A Veritable Flock Of Ducks'
    # - A veritable flock of ducks
    # ?   ^         ^     ^  ^
    # + A Veritable Flock Of Ducks
    # ?   ^         ^     ^  ^
Пакет устроил результат первой проверки (test_one_word), но не результат второй (
test_multiple_words). Стрелки вверх (^) показывают, какие строки отличаются.
Функции capitalize увеличивает только первую букву первого слова. Нам нужна другая функция. 
Используем функцию title(). Результат:
    # Ran 2 tests in 0.002s
    # OK
Все прошло отлично. Хотя на самом деле нет.  Наша функция увеличила букву m в конструкции 
I'm. В документации к функции title() мы обнаружили, что она плохо работает с апострофами. 
"""

"""Пакет doctest
Второй пакет для тестирования стандартной библиотеки — doctest (http://bit.ly/pydoctest). Он 
позволяет писать тесты внутри строки документации, которые и сами будут служить документацией. 
Он выглядит как интерактивный интерпретатор: символы >>>, за ними следует вызов, а затем 
результаты в следующей строке. Смотрите модуль cap_2.by. В случае успеха он не выведет ничего"""

"""Пакет nose
Сторонний пакет nose (https://oreil.ly/gWK6r) — еще одна альтернатива пакету unittest. Вам не 
нужно создавать класс, который содержит тестовые методы, как мы делали при работе с unittest. 
Любая функция, содержащая в своем имени слово test, будет запущена. Смотрите модуль 
test_cap_nose.py"""

"""Другие фреймворки для тестирования По какой-то причине людям нравится писать тестовые 
фреймворки для Python. Можете взглянуть на другие популярные решения:
- tox (http://tox.readthedocs.org/);
- py.test (https://pytest.org/);
- green (https://github.com/CleanCut/green)."""

"""Постоянная интеграция
Когда ваша группа генерирует много кода каждый день, полезно автоматизировать тесты по мере 
появления изменений. Вы можете автоматизировать системы контроля версий так, чтобы тесты 
запускались при возникновении нового кода. Таким образом, каждый будет знать, сломал ли кто-то 
сборку и убежал обедать пораньше — или на новую работу.
Эти системы велики, и я не буду рассматривать детали их установки и использования. Если они вам 
когда-нибудь понадобятся, то вы будете знать, где их искать:
- buildbot (http://buildbot.net/) — эта система контроля версий, написанная на Python, 
    автоматизирует построение, тестирование и выпуск кода;
- jenkins (http://jenkins-ci.org/) — система написана на Java, в данный момент выглядит наиболее 
    предпочтительным инструментом для постоянной интеграции;
- travis-ci (http://travis-ci.com/) — эта система автоматизирует проекты, размещенные на GitHub, 
    бесплатна для проектов с открытым исходным кодом;
- circleci (https://circleci.com/) — эта система коммерческая, но бесплатна для частных проектов и 
    проектов с открытым исходным кодом.
"""

"""Отладка кода
Всегда тестируйте код. Чем лучше ваши тесты, тем меньше кода вам потом придется исправлять.
Обычно код ломается из-за действий, которые вы сделали только что. Поэтому обычно отладка 
выполняется «снизу вверх», начиная с ваших самых последних изменений. Но иногда причина кроется 
где-то еще, в чем-то, чему вы доверяли и думали, что оно работает. Вы могли бы подумать: если бы 
проблема была в том, чем пользовались многие люди, то кто-то уже заметил бы ее. Но так бывает не 
всегда. Самые хитрые баги, которые требовали на свое исправление больше недели, появились из 
внешних источников. Поэтому после того, как обвините человека в зеркале, пересмотрите
свои предположения. Данный подход называется нисходящим и занимает больше времени.
Далее мы рассмотрим некоторые приемы отладки, начиная с быстрых и «грязных» и заканчивая 
медленными и зачастую такими же «грязными»."""

"""Функция print()
Самый простой способ выполнять отладку в Python — построчно выполнять код. Полезно отображать 
результат работы функции vars(), которая извлекает значения ваших локальных переменных, 
включая аргументы функций:"""
def func(*args, **kwargs):
    print(vars())
# func(1, 2, 3)   # {'args': (1, 2, 3), 'kwargs': {}}
"""Зачастую на экран следует выводить locals() и globals(). Если в вашем коде также встречается и стандартный вывод данных, то можете
написать собственные сообщения об ошибке в поток вывода для ошибок с помощью конструкции print(
stuff, file=sys.stderr)."""

"""Отладка с помощью декораторов
Декоратор может вызывать код, располагающийся до или после функции, не модифицируя его внутри 
нее самой. Это значит, что вы можете использовать декоратор для выполнения какого-либо действия 
до или после вызова любой функции, а не только тех, которые написали вы. Определим декоратор 
dump, позволяющий вывести на экран входные аргументы и выводимые значения любой функции по мере 
ее вызова (разработчики знают, что выходные данные нужно декорировать). Смотрите dump.py и 
test_dump.py Перейдем к декорируемой части. Это функция с именем double(), которая принимает 
именованные или безымянные числовые аргументы и возвращает их удвоенные значения в списке"""

"""Отладчик pdb
Эти приемы полезны, но иногда ничто не сможет заменить настоящий отладчик. Большинство IDE 
содержат отладчики, возможности и пользовательские интерфейсы которых могут варьироваться.
Использование стандартного отладчика Python pdb (https://oreil.ly/IIN4y).
Мы собираемся считать файл, содержащий названия стран и их столиц, разделенные запятыми, и вывести
их на экран в формате «столица, страна». Прописные буквы в них могут быть расставлены 
неправильно, так что нам нужно исправить это при выводе на экран. В файле также могут быть 
лишние пробелы, следует избавиться и от них. Наконец, несмотря на то, что было бы логично 
считать весь файл до конца, по какой-то причине наш менеджер сказал нам остановиться, 
если мы встретим слово quit (состоящее из смеси прописных и строчных букв).
Разработаем алгоритм (способ решения задачи). Это псевдокод, он выглядит как программа, но 
является лишь способом выразить логику простым языком до преобразования его в настоящую программу.
Одна из причин, по которым программисты любят Python, — он выглядит очень похожим на псевдокод, 
поэтому его не так трудно преобразовать в рабочую программу, когда приходит время:
"""
# для каждой строки в текстовом файле:
#     считать строку
#     удалить пробелы в начале и конце строки
#     если найдена строка "quit" в строке, записанной в нижнем регистре:
#         остановиться
#     иначе:
#         разделить страну и столицу символом запятой
#         удалить пробелы в начале и конце
#         записать страну и столицу с прописной буквы
#         вывести на экран столицу, запятую и страну
""" Смотрите capitals.py"""
"""Несмотря на то что в файле было 15 строк, программа завершается после вывода всего пяти:"""
"""сможет ли помочь отладчик. Чтобы использовать отладчик, импортируйте модуль pdb из командной 
строки, введя –m pdb, например, так: $ python -m pdb capitals.py cities2.csv. Это запустит 
программу и разместит вас на первой строке. Если вы введете символ с (от слова continue — 
«продолжить»), то программа будет работать, пока не завершится либо естественным образом, 
либо из-за ошибки.
    Программа завершилась нормально, точно так же, как и раньше, когда мы запускали ее вне 
отладчика. Попробуем запустить ее снова, использовав специальные команды, чтобы сузить место 
поиска проблемы. Похоже, имеет место логическая ошибка, а не синтаксическая проблема или исключение
(которые бы выдали сообщение об ошибке). 
    Введите s (step — «шаг»), чтобы пройти по отдельным строкам кода. Это позволит пройти по всем 
строкам кода Python: вашим, стандартной библиотеки и любых других применяемых вами модулей. 
Используя команду s, вы также входите во все функции и проходите каждую построчно. 
    Введите n (next — «следующий»), чтобы идти по шагам, но не заходить внутрь функций: когда вы 
находитесь на строке, где вызывается функция, эта команда выполняет всю функцию и вы оказываетесь 
на следующей строке. Используйте s, если не уверены в том, где конкретно есть проблема, 
а n — будучи уверенными, что некая функция не вызывает проблем, особенно когда она длинная. 
Зачастую вы будете проходить построчно весь свой код и пропускать библиотечный, поскольку 
подразумевается, что он хорошо протестирован. Используем s с целью начать двигаться от начала 
программы к функции process_cities(). 
    Введите l (list — «перечислить»), чтобы увидеть следующие несколько строк своей программы.
    Стрелка (->) указывает на текущую строку. Мы могли бы и дальше применять команды s или n в 
надежде что-то найти, но используем одну из главных особенностей отладчика — точки останова. Такая
точка останавливает выполнение программы на указанной вами строке. В данном случае мы хотим 
узнать, почему функция process_cities() вызывает завершение программы до прочтения всех введенных 
строк. Строка 3 (for line in file:) будет считывать каждую строку входного файла, поэтому выглядит 
невинно. Единственное место, где мы можем вернуться из функции до прочтения всех данных, — это
строка 6 (return). Поставим точку останова на этой строке:
(Pdb) b 6
Breakpoint 1 at /Users/williamlubanovic/Aleksandr Shvec - design patterns/capitals.py:6
Далее продолжим выполнение программы до тех пор, пока она либо не достигнет точки останова, 
либо не завершится обычным образом:
(Pdb) c
Далее продолжим выполнение программы до тех пор, пока она либо не достигнет точки останова, 
либо не завершится обычным образом:
(Pdb) c
можете просмотреть все точки останова с помощью команды b:
(Pdb) b
Вызов команды l без аргументов выведет все строки, начиная с точки предыдущего вызова этой 
команды, поэтому включите в вызов опциональный параметр — стартовую строку (в нашем примере 
начнем с 1):
(Pdb) l 1
Теперь модифицируем наш тест, чтобы выполнялась проверка на полное совпадение со строкой quit 
без всяких других символов. Смотрите capitals.py
Помните: больше тестов — меньше отладки.
"""

"""Записываем в журнал сообщения об ошибках
В какой-то момент вам может понадобиться перейти от использования выражений print() к записи 
сообщений в журнал. Журнал, как правило, представляет собой системный файл, в котором 
накапливаются сообщения, содержащие полезную информацию, например временную метку или имя 
пользователя, запустившего программу. Зачастую журналы ежедневно ротируются (переименовываются) и 
сжимаются, благодаря чему не переполняют ваш диск и не создают проблем. Если ваша программа 
работает «не так», то вы можете просмотреть соответствующий файл журнала и увидеть, 
что произошло. Содержимое исключений особенно полезно записывать в журнал, поскольку оно 
подсказывает номер строки, после выполнения которой программа завершилась, и причину такого 
завершения. Для журналирования используется модуль стандартной библиотеки logging
( http://bit.ly/py-logging ). Модуль logging содержит следующие концепции:
- сообщение, которое вы хотите сохранить в журнал;
- уровни приоритета и соответствующие функции — debug() , info() , warn() ,
    error() и critical() ;
- один или несколько объектов журналирования для основной связи с модулем;
- обработчики, которые направляют значение в терминал, файл, базу данных или
    куда-либо еще;
- средства форматирования выходных данных;
- фильтры, принимающие решения в зависимости от входных данных.
    Глубокое погружение в документацию отвечает на первую загадку : уровень приоритета 
по умолчанию — WARNING, он будет записан в журнал, когда мы вызовем первую функцию 
(logging.debug()). Мы можем указать уровень по умолчанию с помощью функции basicConfig(). Самый
низкий уровень — DEBUG, это дает возможность поймать более высокие уровни:
import logging
logging.basicConfig(level=logging.DEBUG)
logging.debug("It's raining again")                 # DEBUG:root:It's raining again
logging.info("With hail the size of hailstones")    # INFO:root:With hail the size of hailstones
Каждый объект журналирования имеет имя. Создадим объект, который называется bunyan:
import logging
logging.basicConfig(level='DEBUG')
logger = logging.getLogger('bunyan')
logger.debug('Timber!')                             # DEBUG:bunyan:Timber!
Если имя объекта журналирования содержит точки, то они разделяют уровни иерархии таких объектов, 
каждый из которых потенциально имеет разные приоритеты. Это значит, что объект с именем quark выше
объекта quark.charmed. На вершине иерархии находится корневой объект журналирования с именем ' '.
До сего момента мы только выводили сообщения, и это практически не отличается от функции print(). 
Чтобы направить сообщения в разные места назначения, используем обработчики. Самое распространенное
место — файл журнала, направить туда сообщения можно так:"""
import logging
# logging.basicConfig(level='DEBUG', filename='blue_ox.log')
# logger = logging.getLogger('bunyan')
# logger.debug("Where's my axe?")
# logger.warning("I need my axe")
"""Ага, строки больше не показываются на экране, вместо этого попадают в файл blue_ox.log:"""
"""Вызов функции basicConfig() и передача имени файла в качестве аргумента создали для вас объект 
типа FileHandler и сделали его доступным объекту журналирования. Модуль журналирования содержит 
как минимум 15 обработчиков для отправки сообщений в разные места, такие как электронная почта, 
веб-серверы, экраны и файлы. Наконец, вы можете управлять форматом сообщений журнала. В нашем 
первом примере использовался формат по умолчанию. Если вы предоставите строку format функции 
basicConfig(), то можете изменить формат по собственному желанию. """
fmt = '%(asctime)s | %(levelname)s | %(lineno)s | %(message)s'
# logging.basicConfig(level='DEBUG', filename='blue_ox.log', format=fmt)
# logger = logging.getLogger('bunyan')
# logger.error("Where's my other plaid shirt?")
"""Мы позволили объекту журналирования снова отправить выходные данные на экран, но изменили их 
формат. Модуль logging распознал количество имен переменных в строке формата fmt. Мы использовали 
asctime (дата и время как строка ISO 8601), levelname, lineno (номер строки) и само сообщение в 
переменной message. Существуют и другие встроенные переменные, вы можете предоставить и собственные
переменные. Пакет logging содержит гораздо больше особенностей, чем можно описать в приведенном 
небольшом обзоре. Вы можете писать в несколько журналов одновременно, указывая разные приоритеты
и форматы. Данный пакет довольно гибок, но иногда это достигается за счет простоты."""

"""Оптимизация кода
Обычно Python довольно быстр, однако иногда его скорости не хватает. В большинстве случаев вы 
можете ускорить работу, выбрав более качественный алгоритм или структуру данных. Идея заключается 
в том, чтобы знать, где это сделать. Даже опытные программисты ошибаются довольно часто. Нужно 
быть очень осторожными и семь раз отмерить, прежде чем отрезать. Это приводит нас к использованию
таймеров. Измеряем время. функция time модуля time возвращает текущее время в формате epoch как 
число секунд с плавающей точкой. Быстрый способ засечь время — получить текущее, что-то сделать, 
получить новое время и вычесть из него первое. Напишем соответствующий код в time_1.py. Здесь мы 
измеряем время, которое требуется на присвоение значения 5 переменной num и умножение его на 5 . 
Данный пример не является реалистичным тестом производительности, это лишь образец того, 
как замерить время выполнения произвольного кода. Попробуем выполнить что-то помедленнее, скажем 
функцию sleep(). Если мы усыпим выполнение на секунду, то наш таймер покажет значение чуть больше 
секунды. Look at time_2.py .
    Существует более удобный способ измерить время выполнения таких фрагментов кода, как этот,
— использование стандартного модуля timeit ( http://bit.ly/py-timeit ). У него имеется функция с 
именем, как вы уже догадались, timeit() , которая запустит ваш код заданное количество раз и 
выведет результаты. Ее синтаксис выглядит следующим образом: 
timeit.timeit(код, число, количество_раз) .
В примерах этого подраздела код должен находиться в кавычках, чтобы он выполнялся не после нажатия 
клавиши Return , а лишь внутри функции timeit() . можно измерить время выполнения некой функции, 
передав ее имя в функцию timeit() . Look at timeit_1.py. Мы можем использовать аргумент repeat 
функции repeat() модуля timeit , чтобы выполнить код большее количество раз. Look at timeit_2.py
    Использование timeit() означает, что вы оборачиваете код, производительность которого измеряете, 
в строку. А если у вас несколько строк? Вы могли бы передать их как строку с тройными кавычками, 
но такую нотацию будет сложно прочитать. Определим ленивую функцию snooze() , которая дремлет 
одну секунду, как и мы все время от времени. Для начала обернем саму функцию snooze() . Нам нужно 
включить аргументы globals=globals() (это поможет Python найти функцию snooze ) и number=1 (запу-
стить ее только один раз. Look at timeit_3. Или мы можем использовать декоратор. Look at timeit_4.
Еще один вариант — задействовать менеджер контекста. Look at tineit_5. Метод __exit()__ принимает
три дополнительных аргумента, которые мы здесь не использовали; мы могли бы применить *args 
вместо них.
"""

"""Алгоритмы и структуры данных
Дзен Python (http://bit.ly/zen-py) гласит: «Должен существовать один, и желательно только один, 
очевидный способ сделать это». К сожалению, иногда способ не является очевидным и вам приходится 
сравнивать альтернативные варианты. Например, что лучше использовать для создания списка: цикл 
for или включение списка? И что на самом деле значит «лучше»: быстрее, проще для понимания, 
менее затратно по ресурсам или более характерно для Python? В следующем упражнении мы создадим 
список разными способами, сравнив скорость, читабельность и стиль. Смотрите файл time_lists.py.
В каждой функции мы добавляем в список 1000 элементов и вызываем каждую функцию 1000 раз. 
Обратите внимание: в этом тесте мы вызываем функцию timeit(), передавая ей имя функции в качестве 
первого аргумента вместо кода. Включение списка отработало как минимум в два раза быстрее, чем 
добавление элементов в список с помощью функции append(). Как правило, включение быстрее, 
чем создание вручную.
"""

"""Книги
Я обнаружил, что книги, представленные в следующем списке, особенно полезны. Их уровень 
варьируется от начального до продвинутого, в них описываются и Python 2, и Python 3.
- Бизли Д., Джонс Б. Python. Книга рецептов. — М.: ДМК-Пресс, 2020.
- Рейтц К., Шлюссер Т. Автостопом по Python. — СПб.: Питер, 2017.
- Barry P. Head First Python (2nd Edition). — O’Reilly, 2016.
- Beazley D. M. Python Essential Reference. 5th ed. — Addison-Wesley, 2019.
- Gorelick M., Ozsvald I. High Performance Python. — O’Reilly, 2014.
- Maxwell A. Powerful Python. — Powerful Python Press, 2017.
- McKinney W. Python for Data Analysis: Data Wrangling with Pandas, NumPy and IPython. — 
    O’Reilly, 2012.
- Ramalho L. Fluent Python. — O’Reilly, 2015.
- Slatkin B. Effective Python. — Addison-Wesley, 2015.
- Summerfield M. Python in Practice: Create Better Programs Using Concurrency,
    Libraries and Patterns. — Addison-Wesley, 2013.
Конечно же, хороших книг гораздо больше (https://wiki.python.org/moin/PythonBooks)."""

"""Сайты
Вот несколько сайтов, где вы можете найти полезные руководства:
- Python for You and Me (https://pymbook.readthedocs.io/) — введение в Python, в котором также 
    рассматриваются нюансы работы с ОС Windows;
- Real Python (http://realpython.com/) — многие авторы внесли свой вклад в создание
    этих руководств;
- Learn Python the Hard Way (http://learnpythonthehardway.org/book), автор Зед Шоу;
- Dive Into Python 3 (https://oreil.ly/UJcGM), автор Марк Пилгрим;
- Mouse Vs. Python (http://www.blog.pythonlibrary.org/), автор Майкл Дрисколл.
Если вам интересно узнавать о том, что происходит в мире Python, то обратите внимание на эти 
новостные сайты:
- comp.lang.python (http://bit.ly/comp-lang-python);
- comp.lang.python.announce (http://bit.ly/comp-lang-py-announce);
- r/python subreddit (http://www.reddit.com/r/python);
- Planet Python (http://planet.python.org/).
Наконец, рассмотрим сайты, с которых можно скачать разнообразные пакеты:
- The Python Package Index (https://pypi.python.org/pypi);
- Awesome Python (https://awesome-python.com/);
- Stack Overflow Python Questions (https://oreil.ly/S1vEL);
- ActiveState Python recipes (http://code.activestate.com/recipes/langs/python);
- Python packages trending on GitHub (https://github.com/trending?l=python)."""

""" В зависимости от вашего местонахождения вы можете найти группы, увлекающиеся Python 
(http://python.meetup.com/). Проводят встречи и местные пользовательские группы по всему миру 
(https://wiki.python.org/moin/LocalUserGroups)."""