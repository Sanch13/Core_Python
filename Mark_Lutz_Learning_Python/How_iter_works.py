l = [1, 2, 3, 4, 5]  # create new list (sequence)

object_iterable = iter(l)
# create iterable object of l,
# object_iterable = <list_iterator object at 0x0000027FB9B52860>

# print(object_iterable.__next__())
# print(next(object_iterable))
# object_iterable.__next__() or next(object_iterable)
# call method next() or obj.__next__() to move on the next obj


for x in l:
    print(x ** 2, end=' ')
    """Автоматическая итерация. Получает iter, вызывает __next__, перехватывает исключения"""

while True:
    try:
        x = next(object_iterable)
    except StopIteration:
        break
    print(x ** 2, end=' ')
    """Ручная итерация: то, что обычно делают циклы for. Оператор try перехватывает исключения 
    или вызов next(object_iterable)"""

generator = (x ** 2 for x in (1, 2, 3, 4, 5))  # <generator object <genexpr> at 0x000001CD1EB58040>
"""
Генератор - итератор, элементы которого можно итерировать только один раз !!!
Генераторные функции и генераторные выражения сами представляют собой итераторы и потому 
поддерживают только одну активную итерацию. Итератором генератора является сам генератор.
map(), filter(), zip(), sum(), sorted() and other.
"""

L = [1, 2, 3, 4, 5]     # L - итерируемый объект
It = iter(L)            # It - Итератор   <list_iterator object at 0x0000025249E63EB0>
"""
Итерируемый объект - объект, который предоставляет возможность обойти поочередно свои 
элементы. Может быть преобразован к итератору.
It - Итератор - объект, который поддерживает функцию next(). Помнит о том, какой элемент будет 
браться следующий.
"""


Помимо ключевого слова `yield`, **итератор** и **генератор** отличаются в деталях создания, использования и внутреннего устройства.

| Характеристика            | Итератор                          | Генератор                      |
|---------------------------|-----------------------------------|--------------------------------|
| **Создание**              | Реализуется вручную через класс   | Функция с `yield`              |
| **Сохранение состояния**  | Отслеживается вручную             | Автоматически сохраняется      |
| **Потребление памяти**    | Может потреблять много памяти     | Генерирует значения на лету    |
| **Читаемость**            | Требует больше кода               | Легкий и компактный синтаксис  |
| **Сложность**             | Подходит для сложной логики       | Подходит для простой итерации  |
    
---

## 1. **Создание**
- **Итератор**: Требует реализации классовых методов **`__iter__()`** и **`__next__()`** вручную.
- **Генератор**: Создается намного проще — это **функция с `yield`**. Python автоматически создает методы `__iter__()` и `__next__()`.

### Пример итератора:
```python
class MyIterator:
    def __init__(self, start, end):
        self.current = start
        self.end = end

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.end:
            raise StopIteration
        self.current += 1
        return self.current - 1

my_iter = MyIterator(1, 4)

for i in my_iter:
    print(i)  # 1, 2, 3
```

### Пример генератора:
```python
def my_generator(start, end):
    current = start
    while current < end:
        yield current
        current += 1

for i in my_generator(1, 4):
    print(i)  # 1, 2, 3
```

**Разница**: Генератор — это компактный и удобный способ создания итераторов без явной реализации классов и методов.

---

## 2. **Хранение состояния**
- **Итератор**: Вы **вручную** отслеживаете текущее состояние (например, текущий индекс или значение).
- **Генератор**: Python **автоматически сохраняет состояние** выполнения между вызовами `yield`. Включает значения всех локальных переменных и текущую позицию в коде.

### Пример:
```python
# Генератор
def generator():
    print("Начало генератора")
    yield 1
    print("Продолжение генератора")
    yield 2
    print("Завершение генератора")

gen = generator()
print(next(gen))  # Начало генератора -> 1
print(next(gen))  # Продолжение генератора -> 2
```

Здесь генератор автоматически запоминает, на какой строке он остановился после `yield`.

---

## 3. **Память**
- **Итератор**: Может потреблять больше памяти, особенно если данные заранее хранятся в памяти.
- **Генератор**: Генерирует значения **"на лету"** и **не хранит** их в памяти.

### Пример (разница в памяти):
```python
# Итератор (например, создаем вручную список всех чисел)
nums = [i for i in range(1_000_000)]  # Использует много памяти

# Генератор (значения создаются по мере необходимости)
def gen_nums():
    for i in range(1_000_000):
        yield i
```

**Вывод**: Генераторы гораздо эффективнее для больших данных.

---

## 4. **Время жизни**
- **Итератор**: Это объект, который может существовать в программе и после завершения итерации.
- **Генератор**: Объект-генератор "умирает" после **`StopIteration`**, а его память освобождается.

---

## 5. **Читаемость и компактность**
- Генераторы **проще читаются** и пишутся, чем итераторы.  
  Итераторы требуют большего количества кода для достижения той же функциональности.

---

## 6. **Применение**
- **Итераторы**: Используются, если нужно больше **контроля** над состоянием, поведением итерации или нужно добавить сложную логику.
- **Генераторы**: Используются для **ленивой генерации** данных, больших объемов данных и при простых итерационных задачах.

---

## Итоговое сравнение



**Вывод**:  
- Используй **генераторы**, когда тебе нужно **быстро** и **просто** создать итератор.
- Используй **итераторы** с ручной реализацией, когда нужна дополнительная логика и контроль над итерацией.

